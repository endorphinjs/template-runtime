import { elem } from './dom';
import { assign, isDefined, isObject, obj, changeSet, nextTick } from './utils';
import { finalizeEvents } from './event';
import { finalizeProps } from './attribute';
import { createInjector } from './injector';
import { runHook, forEachHook } from './hooks';

/**
 * Creates internal lightweight Endorphin component with given definition
 * @param {string} name
 * @param {ComponentDefinition} definition
 * @param {Component} [host]
 * @returns {Component}
 */
export function createComponent(name, definition, host) {
	/** @type {Component} */
	const element = elem(name, host);
	element.refs = {};
	element.props = collectData(definition, 'props');
	element.state = collectData(definition, 'state');
	element.setProps = (value, silent) => setProps(element, value, silent);
	element.setState = (value, silent) => setState(element, value, silent);
	forEachHook(definition, 'methods', methods => assign(element, methods));

	// XXX Should point to Shadow Root in Web Components
	element.componentView = element;

	// Create slottted input
	const input = createInjector(element.componentView);
	input.slots = obj();

	element.componentModel = {
		definition,
		input,
		vars: obj(),
		partials: obj(),
		refs: changeSet(),
		mounted: false,
		rendering: false,
		update: null,
		queued: null,
		detachEvents: attachStaticEvents(element, definition)
	};

	runHook(element, 'init');

	return element;
}

/**
 * Mounts given component
 * @param {Component} elem
 * @param {object} [initialProps]
 */
export function mountComponent(elem, initialProps) {
	const { componentModel } = elem;
	const { input, definition } = componentModel;
	elem.slots = input.slots;
	finalizeEvents(input);
	finalizeProps(input, initialProps);

	componentModel.rendering = true;
	runHook(elem, 'willMount');
	if (definition.default) {
		runHook(elem, 'willRender');
		componentModel.update = definition.default(elem);
		runHook(elem, 'didRender');
	}
	runHook(elem, 'didMount');
	componentModel.rendering = false;
	componentModel.mounted = true;
}

/**
 * Updates given mounted component
 * @param {Component} elem
 * @param {object} initialProps
 */
export function updateComponent(elem) {
	const { componentModel } = elem;
	finalizeEvents(componentModel.input);
	finalizeProps(componentModel.input);
	renderComponent(elem);
}

/**
 * Destroys given component: removes static event listeners and cleans things up
 * @param {Component} elem
 */
export function unmountComponent(elem) {
	const { componentModel } = elem;
	componentModel.mounted = false;
	componentModel.detachEvents();

	// Detach own handlers
	// XXX doesn‚Äôt remove static events (via direct call of `addStaticEvent()`)
	const ownHandlers = componentModel.input.events.prev;
	for (let p in ownHandlers) {
		elem.removeEventListener(p, ownHandlers[p]);
	}

	runHook(elem, 'didUnmount');
}

/**
 * Queues next component render
 * @param {Component} elem
 */
function renderNext(elem) {
	const { componentModel } = elem;
	if (!componentModel.rendering) {
		renderComponent(elem);
	} else if (!componentModel.queued) {
		componentModel.queued = nextTick(() => renderComponent(elem));
	}
}

/**
 * Renders given component
 * @param {Component} elem
 */
function renderComponent(elem) {
	const { componentModel } = elem;

	componentModel.queued = null;
	componentModel.rendering = true;

	// TODO prepare data for hooks in `mountComponent`?
	runHook(elem, 'willUpdate');
	if (componentModel.update) {
		runHook(elem, 'willRender');
		componentModel.update(elem);
		runHook(elem, 'didRender');
	}
	runHook(elem, 'didUpdate');
	componentModel.rendering = false;
}

/**
 * Updates properties of context component
 * @param {Component} elem
 * @param {object} value
 * @param {boolean} [silent]
 * @this Component
 */
function setProps(elem, value, silent) {
	if (isObject(value)) {
		assign(elem.props, value);
		representProps(elem, value);
		!silent && elem.componentModel.mounted && renderNext(elem);
	}
}

/**
 * Updates state of context component
 * @param {Component} elem
 * @param {object} value
 * @param {boolean} [silent]
 */
function setState(elem, value, silent) {
	if (isObject(value) && assignIfNeeded(elem.state, value) && !silent && elem.componentModel.mounted) {
		renderNext(elem);
	}
}

/**
 * Assign data from `next` to `prev` if there are any updates
 * @param {object} prev
 * @param {object} next
 * @return {boolean} Returns `true` if data was assigned
 */
function assignIfNeeded(prev, next) {
	for (const p in next) {
		if (next.hasOwnProperty(p) && prev[p] !== next[p]) {
			return assign(prev, next);
		}
	}
}

/**
 * Collects data generated by `key` factory
 * @param {ComponentDefinition} definition
 * @param {string} key
 * @return {object} initial
 */
function collectData(definition, key) {
	const data = {};
	forEachHook(definition, key, hook => assign(data, hook()));
	return data;
}

/**
 * Represents given props as attribute values in `elem`
 * @param {HTMLElement} elem
 * @param {object} props
 */
function representProps(elem, props) {
	for (const p in props) {
		let value = props[p];
		const type = typeof(value);

		if (type === 'boolean') {
			value = value ? '' : null;
		} else if (type === 'function') {
			value = 'ùëì';
		} else if (Array.isArray(value)) {
			value = '[]';
		} else if (isDefined(value) && type === 'object') {
			value = '{}';
		}

		isDefined(value) ? elem.setAttribute(p, value) : elem.removeAttribute(p);
	}
}

/**
 * Collects and attaches static event listeners to `component` from given `definition`
 * @param {Component} component
 * @param {ComponentDefinition} definition
 * @return {object} Map of attached event handlers
 */
function attachStaticEvents(component, definition) {
	/** @type {{[name: string]: Array}} */
	const eventMap = obj();

	const handler = function(evt) {
		const listeners = eventMap[evt.type];
		for (let i = 0; i < listeners.length; i++) {
			listeners[i].call(this, evt, component);
		}
	};

	forEachHook(definition, 'events', events => {
		if (events) {
			const names = Object.keys(events);
			for (let i = 0, name; i < names.length; i++) {
				name = names[i];
				if (name in eventMap) {
					eventMap[name].push(events[name]);
				} else {
					component.addEventListener(name, handler);
					eventMap[name] = [events[name]];
				}
			}
		}
	});

	return function detachStaticEvents() {
		for (let p in eventMap) {
			component.removeEventListener(p, handler);
		}
	};
}
