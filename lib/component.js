import { elem } from './dom';
import { assign, isDefined, isObject } from './utils';
import { finalizeEvents } from './event';
import { finalizeProps } from './attribute';
import { createInjector } from './injector';
import { createScope } from './scope';
import { runHook, forEachHook } from './hooks';

/**
 * Creates internal lightweight Endorphin component with given definition
 * @param {string} name
 * @param {ComponentDefinition} definition
 * @param {string} [scope]
 * @returns {ComponentContainer}
 */
export function createComponent(name, definition, scope) {
	const element = elem(name, scope);
	element.refs = {};
	element.props = collectData(definition, 'props');
	element.state = collectData(definition, 'state');
	forEachHook(definition, 'methods', methods => assign(element, methods));

	// XXX Should point to Shadow Root in Web Components
	element.componentView = element;

	const component = {
		element,
		definition,
		injector: createInjector(element.componentView, true),
		scope: createScope(element, definition),
		update: null
	};

	element.setProps = (value, silent) => {
		if (isObject(value)) {
			assign(element.props, value);
			representProps(element, value);
			!silent && renderComponent(component);
		}
	};

	element.setState = (value, silent) => {
		if (isObject(value) && assignIfNeeded(element.state, value) && !silent) {
			renderComponent(component);
		}
	};

	runHook(definition, 'init', [element]);

	return component;
}

/**
 * Mounts given component
 * @param {ComponentContainer} component
 * @param {object} [initialProps]
 */
export function mountComponent(component, initialProps) {
	const { element, injector } = component;
	element.slots = injector.slots;
	finalizeEvents(injector);
	finalizeProps(injector, initialProps);
	renderComponent(component);
}

/**
 * Updates given mounted component
 * @param {ComponentContainer} component
 * @param {object} initialProps
 */
export function updateComponent(component) {
	const { injector } = component;
	finalizeEvents(injector);
	finalizeProps(injector);
}

/**
 * Renders given component
 * @param {ComponentContainer} component
 */
export function renderComponent(component) {
	const { update } = component;
	if (update) {
		update(component);
	} else {
		component.update = component.definition.default(component);
	}
}

/**
 * Assign data from `next` to `prev` if there are any updates
 * @param {object} prev
 * @param {object} next
 * @return {boolean} Retruns `true` if data is assigned
 */
function assignIfNeeded(prev, next) {
	for (const p in next) {
		if (next.hasOwnProperty(p) && prev[p] !== next[p]) {
			return assign(prev, next);
		}
	}
}

/**
 * Collects data generated by `key` factory
 * @param {ComponentDefinition} definition
 * @param {string} key
 * @return {object} initial
 */
function collectData(definition, key) {
	const data = {};
	forEachHook(definition, key, hook => assign(data, hook()));
	return data;
}

/**
 * Represents given props as attribute values in `elem`
 * @param {HTMLElement} elem
 * @param {object} props
 */
function representProps(elem, props) {
	for (const p in props) {
		const value = props[p];
		const type = typeof (value);

		if (!isDefined(value)) {
			elem.removeAttribute(p);
		} else if (type === 'boolean') {
			value ? elem.setAttribute(p, '') : elem.removeAttribute(p);
		} else {
			let attrValue = '';

			if (type === 'string' || type === 'number') {
				attrValue = value;
			} else if (type === 'function') {
				attrValue = 'ùëì';
			} else if (Array.isArray(value)) {
				attrValue = '[]';
			} else if (type === 'object') {
				attrValue = '{}';
			}

			elem.setAttribute(p, attrValue);
		}
	}
}
